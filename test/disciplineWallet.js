// Generated by CoffeeScript 1.12.5
(function() {
  var DisciplineWallet, accounts, async, q;

  DisciplineWallet = artifacts.require('./DisciplineWallet.sol');

  if (typeof q === "undefined" || q === null) {
    q = require('q');
  }

  accounts = [];

  async = require("promise-async");

  contract('DisciplineWallet', function(paccounts) {
    accounts = paccounts;
    console.log(accounts);
    it("should Deploy a wallet with owner", function() {
      var i;
      i = null;
      return DisciplineWallet["new"](12, 1000, {
        from: accounts[0]
      }).then(function(instance) {
        i = instance;
        return i.owner.call();
      }).then(function(result) {
        return assert.equal(result, accounts[0], 'owner was wrong');
      });
    });
    it("should be off when it starts and has no ether", function() {
      var i;
      i = null;
      return DisciplineWallet["new"](12, 1000, {
        from: accounts[0]
      }).then(function(instance) {
        i = instance;
        return i.bActive.call();
      }).then(function(result) {
        return assert.equal(result, false, 'contract was on before getting ether');
      });
    });
    it("should have a function Period that returns the length of a month", function() {
      var i;
      i = null;
      return DisciplineWallet["new"](12, 1000, {
        from: accounts[0]
      }).then(function(instance) {
        i = instance;
        return i.Period.call();
      }).then(function(result) {
        return assert.equal(result.toNumber(), 2649600, 'Period Function doesnt work');
      });
    });
    it("should have a function NextWithdraw that returns the first withdraw time", function() {
      var i, startTime;
      i = null;
      startTime = null;
      return DisciplineWallet["new"](12, 1000, {
        from: accounts[0]
      }).then(function(instance) {
        i = instance;
        return i.contractStart.call();
      }).then(function(result) {
        startTime = result;
        return i.NextWithdraw.call();
      }).then(function(result) {
        return assert.equal(result.toNumber(), startTime.toNumber() + 2649600, 'NextWithdraw doesnt work');
      });
    });
    it("should turn on when sent ether", function() {
      var endBalance0, endBalance1, i, startBalance0, startBalance1;
      i = null;
      startBalance1 = 0;
      endBalance1 = 0;
      startBalance0 = 0;
      endBalance0 = 0;
      return DisciplineWallet["new"](12, 1000, {
        from: accounts[0]
      }).then(function(instance) {
        i = instance;
        return web3.eth.getBalance(accounts[1]);
      }).then(function(result) {
        startBalance1 = result;
        return web3.eth.getBalance(i.address);
      }).then(function(result) {
        startBalance0 = result;
        return web3.eth.sendTransaction({
          from: accounts[1],
          to: i.address,
          value: 14000
        });
      }).then(function(result) {
        return web3.eth.getBalance(accounts[1]);
      }).then(function(result) {
        endBalance1 = result;
        return web3.eth.getBalance(i.address);
      }).then(function(result) {
        endBalance0 = result;
        assert.equal(endBalance0.toNumber(), startBalance0.toNumber() + 14000, 'account 0 didnt update');
        assert.equal(endBalance1.toNumber() < startBalance1.toNumber(), true, 'account 1 didnt update');
        return i.bActive.call();
      }).then(function(result) {
        return assert.equal(result, true, 'contract didnt turn on');
      });
    });
    it("should fail if constructor sent ether", function() {
      var i;
      i = null;
      return DisciplineWallet["new"](12, 1000, {
        from: accounts[0],
        value: 14000
      }).then(function(instance) {
        i = instance;
        return i.bActive.call();
      }).then(function(result) {
        return assert.equal(result, false, 'contract was on before getting ether');
      })["catch"](function(error) {
        return assert.equal(error.toString().indexOf("non-payable") > -1, true, 'didnt find non-payable error');
      });
    });
    it("should allow withdrawl after 1 month and ether goes to owner", function(done) {
      var i, startBalance;
      i = null;
      startBalance = 0;
      DisciplineWallet["new"](12, web3.toWei(0.1, "ether"), {
        from: accounts[0]
      }).then(function(instance) {
        i = instance;
        return web3.eth.sendTransaction({
          from: accounts[1],
          to: i.address,
          value: web3.toWei(1.4, "ether")
        });
      }).then(function(result) {
        return web3.currentProvider.sendAsync({
          jsonrpc: "2.0",
          method: "evm_increaseTime",
          params: [86400 * 34],
          id: new Date().getTime()
        }, function(err) {
          startBalance = web3.eth.getBalance(accounts[0]);
          return i.Withdraw({
            from: accounts[0]
          }).then(function(result) {
            return web3.eth.getBalance(i.address);
          }).then(function(result) {
            assert.equal(result.toNumber(), web3.toWei(1.3, "ether"), 'withdraw wasnt right');
            return web3.eth.getBalance(accounts[0]);
          }).then(function(result) {
            assert.equal(result.toNumber() > startBalance.toNumber() + parseInt(web3.toWei(0.09, "ether")), true, 'eth didnt transfer');
            assert.equal(result.toNumber() < startBalance.toNumber() + parseInt(web3.toWei(0.1, "ether")), true, 'too much eth transfered');
            return done();
          });
        });
      });
    });
    it("should fail on instant withdrawl", function() {
      var i;
      i = null;
      return DisciplineWallet["new"](12, 1000, {
        from: accounts[0]
      }).then(function(instance) {
        i = instance;
        return web3.eth.sendTransaction({
          from: accounts[1],
          to: i.address,
          value: 14000
        });
      }).then(function(result) {
        return i.Withdraw({
          from: accounts[0]
        });
      }).then(function(result) {
        return assert.equal(false, true, 'withdraw didnt fail');
      })["catch"](function(error) {
        if (error.toString().indexOf("invalid op") > -1) {
          return assert.equal(error.toString().indexOf("invalid op") > -1, true, 'didnt find invalid op throw');
        } else {
          return assert(false, error.toString());
        }
      });
    });
    it("should not allow more than term number of withdraws", function(done) {
      var i, startBalance, withdrawFunction;
      i = null;
      startBalance = 0;
      withdrawFunction = function() {
        return q.Promise(function(resolve, reject) {
          return web3.currentProvider.sendAsync({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [86400 * 34],
            id: new Date().getTime()
          }, function(err) {
            return i.Withdraw({
              from: accounts[0]
            }).then(function(result) {
              return resolve(result);
            })["catch"](function(err) {
              return reject(err);
            });
          });
        });
      };
      DisciplineWallet["new"](12, web3.toWei(0.1, "ether"), {
        from: accounts[0]
      }).then(function(instance) {
        i = instance;
        return web3.eth.sendTransaction({
          from: accounts[1],
          to: i.address,
          value: web3.toWei(1.4, "ether")
        });
      }).then(function(result) {
        return async.eachSeries([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], function(item, done) {
          return withdrawFunction().then(function(result) {
            return i.currentTerm.call({
              from: accounts[0]
            });
          }).then(function(result) {
            return done();
          })["catch"](function(err) {
            return done(err);
          });
        });
      }).then(function(result) {
        return assert(false, "shouldnt be here");
      })["catch"](function(error) {
        if (error.toString().indexOf("invalid op") > -1) {
          assert.equal(error.toString().indexOf("invalid op") > -1, true, 'didnt find invalid op throw');
        } else {
          assert(false, error.toString());
        }
        return done();
      });
    });
    it("should not allow withdraw if some time has passed, but not enough", function(done) {
      var i, startBalance, withdrawFunction;
      i = null;
      startBalance = 0;
      withdrawFunction = function(thisTerm) {
        return q.Promise(function(resolve, reject) {
          var timeFudge;
          timeFudge = 0;
          if (thisTerm < 4) {
            timeFudge = 1;
          }
          return web3.currentProvider.sendAsync({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [86400 * 34 * timeFudge],
            id: new Date().getTime()
          }, function(err) {
            return i.Withdraw({
              from: accounts[0]
            }).then(function(result) {
              return resolve(result);
            })["catch"](function(err) {
              return reject(err);
            });
          });
        });
      };
      DisciplineWallet["new"](12, web3.toWei(0.1, "ether"), {
        from: accounts[0]
      }).then(function(instance) {
        i = instance;
        return web3.eth.sendTransaction({
          from: accounts[1],
          to: i.address,
          value: web3.toWei(1.4, "ether")
        });
      }).then(function(result) {
        return async.eachSeries([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], function(item, done) {
          return withdrawFunction(item).then(function(result) {
            return i.currentTerm.call({
              from: accounts[0]
            });
          }).then(function(result) {
            return done();
          })["catch"](function(err) {
            return done(err);
          });
        });
      }).then(function(result) {
        return assert(false, "shouldnt be here");
      })["catch"](function(error) {
        if (error.toString().indexOf("invalid op") > -1) {
          assert.equal(error.toString().indexOf("invalid op") > -1, true, 'didnt find invalid op throw');
        } else {
          assert(false, error.toString());
        }
        return done();
      });
    });
    it("should allow withdraw all after term is over", function(done) {
      var i, startBalance, withdrawFunction;
      i = null;
      startBalance = 0;
      withdrawFunction = function() {
        return q.Promise(function(resolve, reject) {
          return web3.currentProvider.sendAsync({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [86400 * 34],
            id: new Date().getTime()
          }, function(err) {
            return i.Withdraw({
              from: accounts[0]
            }).then(function(result) {
              return web3.eth.getBalance(i.address);
            }).then(function(result) {
              return resolve(result);
            })["catch"](function(err) {
              return reject(err);
            });
          });
        });
      };
      DisciplineWallet["new"](12, web3.toWei(0.1, "ether"), {
        from: accounts[0]
      }).then(function(instance) {
        i = instance;
        return web3.eth.sendTransaction({
          from: accounts[1],
          to: i.address,
          value: web3.toWei(1.4, "ether")
        });
      }).then(function(result) {
        return async.eachSeries([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], function(item, done) {
          return withdrawFunction().then(function(result) {
            return i.currentTerm.call({
              from: accounts[0]
            });
          }).then(function(result) {
            return done();
          })["catch"](function(err) {
            return done(err);
          });
        });
      }).then(function(result) {
        return web3.eth.getBalance(i.address);
      }).then(function(result) {
        assert.equal(result.toNumber(), parseInt(web3.toWei(0.2, "ether")), "contract had less than expected");
        return web3.eth.getBalance(accounts[0]);
      }).then(function(result) {
        startBalance = result;
        return i.WithdrawAll(accounts[0], {
          from: accounts[0]
        });
      }).then(function(result) {
        return web3.eth.getBalance(i.address);
      }).then(function(result) {
        assert.equal(result.toNumber(), parseInt(web3.toWei(0.0, "ether")), "contract had more than expected");
        return web3.eth.getBalance(accounts[0]);
      }).then(function(result) {
        assert.equal(result.toNumber() > startBalance.toNumber() + parseInt(web3.toWei(0.19, "ether")), true, "not enough withdrawn");
        assert.equal(result.toNumber() < startBalance.toNumber() + parseInt(web3.toWei(0.21, "ether")), true, "too much withdrawn");
        return done();
      })["catch"](function(error) {
        if (error.toString().indexOf("invalid op") > -1) {
          assert.equal(error.toString().indexOf("invalid op") > -1, false, 'found an op throw');
        } else {
          assert(false, error.toString());
        }
        return done();
      });
    });
    it("should fail if withdrawAll is called before term is over", function(done) {
      var i, startBalance, withdrawFunction;
      i = null;
      startBalance = 0;
      withdrawFunction = function(thisTerm) {
        return q.Promise(function(resolve, reject) {
          var timeFudge;
          timeFudge = 0;
          if (thisTerm < 4) {
            timeFudge = 1;
          }
          return web3.currentProvider.sendAsync({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [86400 * 34 * timeFudge],
            id: new Date().getTime()
          }, function(err) {
            return i.Withdraw({
              from: accounts[0]
            }).then(function(result) {
              return resolve(result);
            })["catch"](function(err) {
              return reject(err);
            });
          });
        });
      };
      DisciplineWallet["new"](12, web3.toWei(0.1, "ether"), {
        from: accounts[0]
      }).then(function(instance) {
        i = instance;
        return web3.eth.sendTransaction({
          from: accounts[1],
          to: i.address,
          value: web3.toWei(1.4, "ether")
        });
      }).then(function(result) {
        return async.eachSeries([1, 2, 3], function(item, done) {
          return withdrawFunction(item).then(function(result) {
            return i.currentTerm.call({
              from: accounts[0]
            });
          }).then(function(result) {
            return done();
          })["catch"](function(err) {
            return done(err);
          });
        });
      }).then(function(result) {
        return i.WithdrawAll(accounts[0], {
          from: accounts[0]
        });
      }).then(function() {
        assert(false, 'shouldnt be here');
        return done();
      })["catch"](function(error) {
        if (error.toString().indexOf("invalid op") > -1) {
          assert.equal(error.toString().indexOf("invalid op") > -1, true, 'didnt find invalid op throw');
        } else {
          assert(false, error.toString());
        }
        return done();
      });
    });
    it("should reject payment if payout term is expired", function(done) {
      var i, startBalance, withdrawFunction;
      i = null;
      startBalance = 0;
      withdrawFunction = function() {
        return q.Promise(function(resolve, reject) {
          return web3.currentProvider.sendAsync({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [86400 * 34],
            id: new Date().getTime()
          }, function(err) {
            return i.Withdraw({
              from: accounts[0]
            }).then(function(result) {
              return web3.eth.getBalance(i.address);
            }).then(function(result) {
              return resolve(result);
            })["catch"](function(err) {
              return reject(err);
            });
          });
        });
      };
      DisciplineWallet["new"](12, web3.toWei(0.1, "ether"), {
        from: accounts[0]
      }).then(function(instance) {
        i = instance;
        return web3.eth.sendTransaction({
          from: accounts[1],
          to: i.address,
          value: web3.toWei(1.4, "ether")
        });
      }).then(function(result) {
        return async.eachSeries([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], function(item, done) {
          return withdrawFunction().then(function(result) {
            return i.currentTerm.call({
              from: accounts[0]
            });
          }).then(function(result) {
            return done();
          })["catch"](function(err) {
            return done(err);
          });
        });
      }).then(function(result) {
        return web3.eth.sendTransaction({
          from: accounts[1],
          to: i.address,
          value: web3.toWei(1.4, "ether")
        });
      }).then(function(result) {
        assert(false, "shouldnt be here");
        return done();
      })["catch"](function(error) {
        if (error.toString().indexOf("invalid op") > -1) {
          assert.equal(error.toString().indexOf("invalid op") > -1, true, 'found an op throw');
        } else {
          assert(false, error.toString());
        }
        return done();
      });
    });
    it("should deposit using deposit function", function(done) {
      var i, startBalance;
      i = null;
      startBalance = 0;
      DisciplineWallet["new"](12, web3.toWei(0.1, "ether"), {
        from: accounts[0]
      }).then(function(instance) {
        i = instance;
        return i.Deposit({
          from: accounts[1],
          value: web3.toWei(1.4, "ether")
        });
      }).then(function(result) {
        return web3.eth.getBalance(i.address);
      }).then(function(result) {
        assert.equal(result.toNumber(), parseInt(web3.toWei(1.4, "ether")), "deposit didnt work");
        return done();
      });
    });
    it("should allow for transfer of owner", function(done) {
      var endBalance, i, startBalance, withdrawFunction;
      i = null;
      startBalance = 0;
      endBalance = 0;
      withdrawFunction = function(fromAddress) {
        return q.Promise(function(resolve, reject) {
          return web3.currentProvider.sendAsync({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [86400 * 34],
            id: new Date().getTime()
          }, function(err) {
            return i.Withdraw({
              from: fromAddress
            }).then(function(result) {
              return web3.eth.getBalance(i.address);
            }).then(function(result) {
              return resolve(result);
            })["catch"](function(err) {
              return reject(err);
            });
          });
        });
      };
      DisciplineWallet["new"](12, web3.toWei(0.1, "ether"), {
        from: accounts[0]
      }).then(function(instance) {
        i = instance;
        return web3.eth.sendTransaction({
          from: accounts[1],
          to: i.address,
          value: web3.toWei(1.4, "ether")
        });
      }).then(function(result) {
        return async.eachSeries([1, 2, 3, 4], function(item, done) {
          return withdrawFunction(accounts[0]).then(function(result) {
            return i.currentTerm.call({
              from: accounts[0]
            });
          }).then(function(result) {
            return done();
          })["catch"](function(err) {
            return done(err);
          });
        });
      }).then(function(result) {
        return i.transferOwnership(accounts[2], {
          from: accounts[0]
        });
      }).then(function(result) {
        return i.owner.call();
      }).then(function(result) {
        return assert.equal(accounts[2], result, "new owner wasnt set");
      }).then(function(result) {
        startBalance = web3.eth.getBalance(accounts[2]);
        return withdrawFunction(accounts[2]);
      }).then(function(result) {
        endBalance = web3.eth.getBalance(accounts[2]);
        assert.equal(endBalance.toNumber() > startBalance.toNumber() + parseInt(web3.toWei(0.09, "ether")), true, "not enough withdrawn");
        assert.equal(endBalance.toNumber() < startBalance.toNumber() + parseInt(web3.toWei(0.1, "ether")), true, "too much withdrawn");
        return withdrawFunction(accounts[0]);
      }).then(function() {
        assert(false, 'shouldnt be here');
        return done();
      })["catch"](function(error) {
        if (error.toString().indexOf("invalid op") > -1) {
          assert.equal(error.toString().indexOf("invalid op") > -1, true, 'found an op throw');
        } else {
          assert(false, error.toString());
        }
        return done();
      });
    });
    return it("should reduce payout if payout would drain account before the end of the term", function(done) {
      var i, startBalance;
      i = null;
      startBalance = 0;
      DisciplineWallet["new"](12, web3.toWei(0.1, "ether"), {
        from: accounts[0]
      }).then(function(instance) {
        i = instance;
        return web3.eth.sendTransaction({
          from: accounts[1],
          to: i.address,
          value: web3.toWei(0.6, "ether")
        });
      }).then(function(result) {
        return web3.currentProvider.sendAsync({
          jsonrpc: "2.0",
          method: "evm_increaseTime",
          params: [86400 * 34],
          id: new Date().getTime()
        }, function(err) {
          startBalance = web3.eth.getBalance(accounts[0]);
          return i.Withdraw({
            from: accounts[0]
          }).then(function(result) {
            return web3.eth.getBalance(i.address);
          }).then(function(result) {
            console.log(result);
            assert.equal(result.toNumber(), web3.toWei(0.55, "ether"), 'withdraw wasnt right');
            return web3.eth.getBalance(accounts[0]);
          }).then(function(result) {
            assert.equal(result.toNumber() > startBalance.toNumber() + parseInt(web3.toWei(0.04, "ether")), true, 'eth didnt transfer');
            assert.equal(result.toNumber() < startBalance.toNumber() + parseInt(web3.toWei(0.5, "ether")), true, 'too much eth transfered');
            return done();
          });
        });
      });
    });
  });

}).call(this);
